{-# LANGUAGE LambdaCase #-}{-# LANGUAGE ScopedTypeVariables #-}{-# LANGUAGE RankNTypes #-}module ValiGen.ValiGen  whereimport Test.QuickCheckdata ValiGen v a  = Var v  | OneOf [a]  | Choose (a, a)  | Not (ValiGen v a)  | Union (ValiGen v a) (ValiGen v a)  | Intersect (ValiGen v a) (ValiGen v a)  | Implies (ValiGen v a) (v -> ValiGen v a)class Negate a where  neg :: a -> adata ChooseUnion a  = Range (a, a)  | ChooseUnion (ChooseUnion a) (ChooseUnion a)instance Semigroup (ChooseUnion a) where  (<>) = ChooseUnion-- | NbE-style interpretationdata Value a  = VNeutral (Neutral a)  | VOneOf [a]  | VChooseUnion (ChooseUnion a)  | VOneOfChoose [a] (ChooseUnion a)  -- | VTruedata Neutral a  = NNot (Value a)  | NImplies (Neutral a) (Abstraction a)  | NUnion1 (Neutral a) (Value a)  | NUnion2 (Value a) (Neutral a)  | NIntersect1 (Neutral a) (Value a)  | NIntersect2 (Value a) (Neutral a)newtype Abstraction a = Abstraction { runAbstraction :: Value a -> Value a }validate :: Eq a => Value a -> (a -> Bool)validate (VNeutral n) z = validateNeutral n zvalidate (VOneOf xs) z = z `elem` xsvalidateNeutral :: Eq a => Neutral a -> (a -> Bool)validateNeutral (NNot x) z = not $ validate x zvalidateNeutral (NImplies x f) z = validateNeutral x z || not (validate (runAbstraction f (VNeutral x)) z)validateNeutral (NUnion1 x y) z = validateNeutral x z || validate y zvalidateNeutral (NUnion2 x y) z = validate x z || validateNeutral y zvalidateNeutral (NIntersect1 x y) z = validateNeutral x z && validate y zvalidateNeutral (NIntersect2 x y) z = validate x z && validateNeutral y zgen :: Enum a => Value a -> Gen agen (VOneOf xs) = elements xsgen (VChooseUnion p) = genChooseUnion pgen (VOneOfChoose xs p) = oneof [genChooseUnion p, elements xs]gen (VNeutral n) = genNeutral ngenChooseUnion :: Enum a => ChooseUnion a -> Gen agenChooseUnion (Range p) = chooseEnum pgenChooseUnion (ChooseUnion x y) = oneof [genChooseUnion x, genChooseUnion y]genNeutral :: Enum a => Neutral a -> Gen agenNeutral (NNot x) = error "genNeutral NNot"genNeutral (NImplies x f) = genNeutral x >>= (gen . runAbstraction f . VOneOf . (:[]))genNeutral (NIntersect1 x y) = oneof [genNeutral x, gen y]genNeutral (NIntersect2 x y) = oneof [gen x, genNeutral y]genNeutral (NUnion1 {}) = error "genNeutral NUnion1"genNeutral (NUnion2 {}) = error "genNeutral NUnion2"reify :: Value a -> ValiGen v areify = undefinedeval :: ValiGen (Value a) a -> Value aeval vg = case vg of  Var x -> x  OneOf xs -> VOneOf xs  Implies x f -> --VNeutral $ NImplies (eval x) $ Abstraction (eval . f)    case eval x of      VNeutral nX -> VNeutral $ NImplies nX $ Abstraction (eval . f)      xV -> eval $ f xV  Union x y -> evalUnion x y  Not x -> evalNot xevalNot :: ValiGen (Value a) a -> Value aevalNot = \case  Intersect x y -> evalUnion (Not x) (Not y)  _ -> error "evalNot: something other than Intersect"evalUnion :: ValiGen (Value a) a -> ValiGen (Value a) a -> Value aevalUnion x y =  case eval x of    VNeutral nX -> VNeutral $ NUnion1 nX $ eval y    VOneOf xs -> evalUnion2 (VOneOf xs) y    VChooseUnion p -> evalUnion2 (VChooseUnion p) yevalUnion2 :: Value a -> ValiGen (Value a) a -> Value aevalUnion2 xV y =  case eval y of    VNeutral nY -> VNeutral $ NUnion2 xV nY    yV -> liftedUnion xV yVunionOneOf :: [a] -> Value a -> Value aunionOneOf xs (VOneOf ys) = VOneOf (xs ++ ys)unionOneOf xs (VOneOfChoose ys p) = VOneOfChoose (xs ++ ys) punionOneOf xs (VChooseUnion p) = VOneOfChoose xs punionChoose :: ChooseUnion a -> Value a -> Value aunionChoose p (VChooseUnion q) = VChooseUnion (p <> q)unionChoose p (VOneOf ys) = unionOneOf ys (VChooseUnion p)unionChoose p (VOneOfChoose ys q) = VOneOfChoose ys (p <> q)liftedUnion :: Value a -> Value a -> Value aliftedUnion (VOneOf xs) y = unionOneOf xs yliftedUnion (VChooseUnion p) y = unionChoose p yliftedUnion x (VOneOf ys) = unionOneOf ys xliftedUnion x (VChooseUnion p) = unionChoose p xliftedUnion (VOneOfChoose xs p) y = unionChoose p (unionOneOf xs y)liftedUnion x (VOneOfChoose ys p) = unionChoose p (unionOneOf ys x)-- -- verify :: ValiGen a ->-- -- import Control.Monad.Free-- ---- -- -- newtype Verifier a = Verifier  [a]-- -- --   deriving (Functor, Applicative, Show)-- ---- -- -- data Verify a-- -- --   = One a-- -- --   | Equal a a-- ---- ---- -- -- We want something that we behave like (a -> Bool), but is a deep-- -- -- embedding-- ---- -- data VerifyF b a-- --   = OneOf [a]-- ---- --   -- | NotOneOf (b -> Bool) -- TODO: What is the generator interpretation of this?-- ---- --   | Union a a-- --   | Intersect a a-- --   | Neg a-- --   -- | Implies a (b -> a)-- --   deriving (Functor)-- ---- -- type Verify' b = Free (VerifyF b)-- ---- -- type Verify a = Verify' a a-- ---- -- oneOf :: [a] -> Verify a-- -- oneOf = wrap . OneOf . map pure-- ---- -- union :: Verify a -> Verify a -> Verify a-- -- union x = wrap . Union x-- ---- -- intersect :: Verify a -> Verify a -> Verify a-- -- intersect x = wrap . Intersect x-- ---- -- -- We should have:-- -- ---- -- --   intersect a c <= b   <--->   c <= implies a b-- -- ---- -- -- where <= is the sublist ordering-- -- ---- -- implies :: Verify a -> Verify a -> Verify a-- -- implies a b = neg a `union` b-- ---- -- neg :: Verify a -> Verify a-- -- neg = undefined-- -- -- neg (Pure z) = wrap $ NotOneOf [pure z]-- -- -- neg (Free (NotOneOf xs)) = wrap $ OneOf xs-- -- -- neg (Free (Union xs ys)) = wrap $ Intersect (neg xs) (neg ys)-- -- -- neg (Free (Intersect xs ys)) = wrap $ Union (neg xs) (neg ys)-- ---- -- -- neg :: Verify a -> Verify a-- -- -- neg = wrap . Neg-- -- -- -- neg x = implies x (const (oneOf []))-- ---- -- verifyWith :: forall a. (a -> a -> Bool) -> Verify a -> a -> Bool-- -- verifyWith eq = go-- --   where-- --     go :: Verify a -> a -> Bool-- --     go (Pure z) x = x `eq` z-- --     go (Free (OneOf xs)) x = any (`go` x) xs-- --     go (Free (NotOneOf xs)) x = not (any (`go` x) xs)-- --     go (Free (Union xs ys)) x = go xs x || go ys x-- --     go (Free (Intersect xs ys)) x = go xs x && go ys x-- --     -- go (Free (Neg xs)) x = not (go xs x)-- ---- -- verify :: Eq a => Verify a -> a -> Bool-- -- verify = verifyWith (==)-- ---- -- -- Laws:-- -- ---- -- -- * all (verify v) (gen v) == True-- -- ---- -- -- * forall x. verify v x ==> (exists n. x == (gen v !! n))-- -- ---- -- gen :: forall a. Verify a -> [a]-- -- gen = undefined-- ---- -- genAndShrinkWith :: forall a. Subterms a => (a -> a -> Bool) -> Verify a -> [a]-- -- genAndShrinkWith = undefined-- ---- -- genAndShrink :: (Subterms a, Eq a) => Verify a -> [a]-- -- genAndShrink = genAndShrinkWith (==)-- ---- -- class Subterms a where-- --   subterms :: a -> [a]-- ---- -- shrinkWith :: Subterms a => (a -> a -> Bool) -> Verify a -> a -> [a]-- -- shrinkWith eq v = filter (verifyWith eq v) . subterms-- ---- -- -- Laws:-- -- ---- -- -- * forall x. verify v x ==> all (verify v) (shrink x)-- -- shrink :: (Subterms a, Eq a) => Verify a -> a -> [a]-- -- shrink = shrinkWith (==)-- ---- -- -- data Verify' b a-- -- --   = OneOf [a]-- -- --   | Union (Verify' b a) (Verify' b a)-- -- --   | Intersect (Verify' b a) (Verify' b a)-- -- --   | Implies (Verify' b a) (b -> Verify' b a)-- -- --   deriving (Functor)-- ---- -- -- instance Applicative (Verify' b)-- -- ---- -- -- instance Monad (Verify' b) where-- -- --   OneOf xs >>= f =-- -- --     let ys = map f xs-- -- --     in-- -- --     _-- -- ---- -- -- type Verify a = Verify' a a-- -- ---- -- -- neg :: Verify a -> Verify a-- -- -- neg x = Implies x (\_ -> OneOf [])-- -- ---- -- -- verifyWith :: (a -> a -> Bool) -> Verify a -> a -> Bool-- -- -- verifyWith eq = go-- -- --   where-- -- --     go (OneOf xs) x = any (`eq` x) xs-- -- --     go (Union xs ys) x = go xs x || go ys x-- -- --     go (Intersect xs ys) x = go xs x && go ys x-- -- --     go (Implies xs f) x =-- -- --       not (go xs x) || go (f x) x-- -- ---- -- -- -- A condition that should hold: verify (neg xs) x <=> not (verify xs x)-- -- ---- -- -- gen :: Verify a -> [a]-- -- -- gen = undefined-- -- ---- -- -- verify :: Eq a => Verify a -> a -> Bool-- -- -- verify = verifyWith (==)-- -- ---- -- -- -- verify (x `equal` y)-- -- --